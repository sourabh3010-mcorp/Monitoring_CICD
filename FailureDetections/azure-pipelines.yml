trigger:
  branches:
    include:
      - main

pool:
  vmImage: ubuntu-latest

parameters:
  - name: environment
    displayName: "Environment"
    type: string
    default: "qa"
    values:
      - qa
      - prod

variables:
  environment: ${{ parameters.environment }}
  # Ensure the following secure variables exist in the pipeline or variable group if you still need them:
  # TF_CLIENT_ID (secret), TF_CLIENT_SECRET (secret), TF_TENANT_ID (secret), TF_SUBSCRIPTION_ID (secret)

steps:
  - checkout: self

  # ======================================================
  # Install Terraform 1.7.5
  # ======================================================
  - script: |
      sudo apt-get update -y
      wget -qO- https://aka.ms/InstallAzureCLIDeb | sudo bash
      sudo apt-get install -y wget unzip
      wget https://releases.hashicorp.com/terraform/1.7.5/terraform_1.7.5_linux_amd64.zip
      unzip -o terraform_1.7.5_linux_amd64.zip
      sudo mv -f terraform /usr/local/bin/
      terraform -version
    displayName: "Install Terraform 1.7.5"

  # ======================================================
  # Export SP credentials as ARM_* environment variables for Terraform
  # (this step only echoes values for visibility — keep secrets in variable groups or KeyVault)
  # ======================================================
  - script: |
      echo "Exporting Service Principal credentials as ARM_* env variables"
      echo "ARM_CLIENT_ID: $(TF_CLIENT_ID)"
      echo "ARM_CLIENT_SECRET: [hidden]"
      echo "ARM_TENANT_ID: $(TF_TENANT_ID)"
      echo "ARM_SUBSCRIPTION_ID: $(TF_SUBSCRIPTION_ID)"
    displayName: "Set ARM_* environment variables for Terraform"

  # ======================================================
  # Terraform Init (runs from FailureDetections/terraform)
  # ======================================================
  - script: |
      echo "Initializing Terraform backend for environment: $(environment)"
      terraform init -upgrade \
        -backend-config="resource_group_name=tfstate-rg-monitoring" \
        -backend-config="storage_account_name=tfstatestoracct02" \
        -backend-config="container_name=tfstate" \
        -backend-config="key=$(environment).tfstate" \
        -backend-config="access_key=WfJKRgecjuhKEpFCrU3xkF8Dd1kFgKGFR6ygi5ApP8O+XsAgqsFX4KVp1AXQSAohg9DDXOw7zZmz+ASt+YzJTw=="
    workingDirectory: FailureDetections/terraform
    displayName: "Terraform Init"
    env:
      ARM_CLIENT_ID: $(TF_CLIENT_ID)
      ARM_CLIENT_SECRET: $(TF_CLIENT_SECRET)
      ARM_TENANT_ID: $(TF_TENANT_ID)
      ARM_SUBSCRIPTION_ID: $(TF_SUBSCRIPTION_ID)

# ======================================================
  # Terraform Validate
  # ======================================================
  - script: terraform validate
    workingDirectory: FailureDetections/terraform
    displayName: "Terraform Validate"
    env:
      ARM_CLIENT_ID: $(TF_CLIENT_ID)
      ARM_CLIENT_SECRET: $(TF_CLIENT_SECRET)
      ARM_TENANT_ID: $(TF_TENANT_ID)
      ARM_SUBSCRIPTION_ID: $(TF_SUBSCRIPTION_ID)

  # ======================================================
  # Debug listing (optional, keeps as you had)
  # ======================================================
  - script: |
      set -euo pipefail
      echo "Agent sources directory: $(Build.SourcesDirectory)"
      echo "Listing repo root:"
      ls -la "$(Build.SourcesDirectory)" || true

      echo
      echo "Looking for FailureDetections directory (case-sensitive):"
      if [ -d "$(Build.SourcesDirectory)/FailureDetections" ]; then
        echo "Found FailureDetections:"
        ls -la "$(Build.SourcesDirectory)/FailureDetections" || true
      else
        echo "FailureDetections directory NOT found at: $(Build.SourcesDirectory)/FailureDetections"
      fi

      echo
      echo "Searching for Terraform files in the repo (shows paths of committed .tf files and .tfvars):"
      cd "$(Build.SourcesDirectory)"
      git ls-files | grep '\.tf$' || echo "No .tf files found in repo (git ls-files returned nothing)."
      git ls-files | grep '\.tfvars$' || echo "No .tfvars files found in repo (git ls-files returned nothing)."

      echo
      echo "If the terraform files are located at a different path, update your workingDirectory or `cd` to the correct folder."
    displayName: "Debug: list repo and find Terraform files"

  # ======================================================
  # Terraform Plan — replaced with AzureCLI@2 to use the service connection
  # This avoids tenant placeholder issues and uses the service connection for auth.
  # Uses <env>.tfvars located in FailureDetections/terraform (qa.tfvars or prod.tfvars)
  # ======================================================
  - task: AzureCLI@2
    displayName: "Terraform Plan (authenticate with service connection & plan)"
    inputs:
      azureSubscription: 'VS Professional Subscription-Nitin Pradhan'   # <-- REPLACE with your Azure service connection name
      scriptType: bash
      scriptLocation: inlineScript
      inlineScript: |
        set -euo pipefail

        TF_WORKDIR="$(Build.SourcesDirectory)/FailureDetections/terraform"
        echo "Agent sources directory: $(Build.SourcesDirectory)"
        echo "Terraform working dir: $TF_WORKDIR"

        if [ ! -d "$TF_WORKDIR" ]; then
          echo "ERROR: Terraform working directory not found: $TF_WORKDIR"
          ls -la "$(Build.SourcesDirectory)" || true
          exit 1
        fi
        cd "$TF_WORKDIR"

        # Resolve environment (runtime variable falls back to compile-time parameter)
        echo "Compile-time parameter.environment = '${{ parameters.environment }}'"
        echo "Runtime variable environment = '${environment:-<not-set>}'"
        ENV="${environment:-${{ parameters.environment }}}"
        if [ -z "$ENV" ]; then
          echo "ERROR: environment not set; set the pipeline parameter 'environment' (qa or prod)."
          exit 1
        fi
        echo "Using environment: $ENV"

        # Select var-file at terraform root: qa.tfvars or prod.tfvars
        TFVARS_FILE="${ENV}.tfvars"
        if [ ! -f "$TFVARS_FILE" ]; then
          echo "ERROR: Expected var-file '$TFVARS_FILE' not found in $TF_WORKDIR."
          echo "Contents of terraform/:"
          ls -la
          exit 1
        fi
        echo "Using var-file: $TFVARS_FILE"

        # fail fast if literal placeholder remains in repo
        if git grep -n --heading --line-number '\$(tf_tenant_id)' >/dev/null 2>&1; then
          echo "ERROR: Found literal placeholder '\$(tf_tenant_id)' in the repository. Remove/replace it (do NOT leave placeholder text in tfvars/provider files)."
          git grep -n --heading --line-number '\$(tf_tenant_id)'
          exit 1
        fi

        # Get subscription & tenant from the service connection (AzureCLI@2 handles login)
        SUBSCRIPTION_ID=$(az account show --query id -o tsv)
        TENANT_ID=$(az account show --query tenantId -o tsv)
        printf "az account show -> subscription: <<%s>> tenant: <<%s>>\n" "$SUBSCRIPTION_ID" "$TENANT_ID"

        # Let the azurerm provider use Azure CLI auth
        export ARM_USE_AZURECLI_AUTH=true
        export ARM_SUBSCRIPTION_ID="$SUBSCRIPTION_ID"
        export ARM_TENANT_ID="$TENANT_ID"

        echo "Running terraform validate..."
        terraform validate

        echo "Running terraform plan (saving to tfplan)..."
        terraform plan -var-file="$TFVARS_FILE" -out=tfplan -input=false

        echo "Terraform plan completed. Plan saved to: $(pwd)/tfplan"
    env:
      # make runtime environment variable available inside the task script
      environment: $(environment)

  # ======================================================
  # (Optional) You can add Apply step here — recommended to use AzureCLI@2 as well and apply the saved tfplan.
  # ======================================================

  - task: AzureCLI@2
    displayName: "Terraform Apply (apply saved tfplan using Azure service connection)"
    inputs:
      azureSubscription: 'VS Professional Subscription-Nitin Pradhan'
      scriptType: bash
      scriptLocation: inlineScript
      inlineScript: |
        set -euo pipefail

        TF_WORKDIR="$(Build.SourcesDirectory)/FailureDetections/terraform"
        echo "Terraform working dir: $TF_WORKDIR"
        cd "$TF_WORKDIR" || { echo "ERROR: Terraform working directory not found: $TF_WORKDIR"; exit 1; }

        # Resolve environment (runtime variable)
        ENV="${environment:-}"
        if [ -z "$ENV" ]; then
          echo "ERROR: pipeline variable 'environment' is empty. Provide the environment parameter (e.g. qa or prod)."
          exit 1
        fi
        echo "Using environment: $ENV"

        # Ensure Azure CLI is logged in via the service connection
        echo "Checking Azure CLI login..."
        az account show --output table

        # Capture subscription and tenant from Azure CLI
        SUBSCRIPTION_ID=$(az account show --query id -o tsv)
        TENANT_ID=$(az account show --query tenantId -o tsv)
        echo "Using subscription: $SUBSCRIPTION_ID, tenant: $TENANT_ID"

        # Force Terraform to use Azure CLI auth for both providers
        export ARM_SUBSCRIPTION_ID="$SUBSCRIPTION_ID"
        export ARM_TENANT_ID="$TENANT_ID"

        # Apply saved tfplan if it exists
        if [ -f tfplan ]; then
          echo "Found saved plan file: tfplan — applying it now"
          terraform apply -input=false -auto-approve tfplan
          exit_code=$?
          if [ $exit_code -ne 0 ]; then
            echo "ERROR: 'terraform apply' failed with exit code $exit_code"
            exit $exit_code
          fi
          echo "Terraform apply completed successfully (applied tfplan)."
        else
          echo "ERROR: No saved plan file 'tfplan' found. Aborting."
          exit 1
        fi
    env:
      environment: $(environment)
      ARM_USE_AZURECLI_AUTH: true
      AZAPI_USE_AZURECLI_AUTH: true
      ARM_CLIENT_ID: $(TF_CLIENT_ID)
      ARM_CLIENT_SECRET: $(TF_CLIENT_SECRET)
      ARM_TENANT_ID: $(TF_TENANT_ID)
      ARM_SUBSCRIPTION_ID: $(TF_SUBSCRIPTION_ID)


